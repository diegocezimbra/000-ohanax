<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>23 — API Design - Versionamento & Gateway | Full-Stack Mastery</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@300;400;500;600;700;800&family=Source+Serif+4:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
--bg:#0c0e12;--bg2:#12151b;--bg3:#181c24;--bg4:#1e2330;
--text:#d4d8e0;--text2:#8b92a0;--text3:#5c6370;
--accent:#3dd68c;--accent2:#2bb87a;--accent-dim:rgba(61,214,140,.08);
--orange:#e8915a;--blue:#5b9cf5;--purple:#b07aee;--red:#e05c6c;--yellow:#e2c55a;--cyan:#56b6c2;
--code-bg:#0d1017;--code-border:#1a1f2a;
--card:#151921;--card-border:#1e2430;
--radius:12px;--radius-sm:8px;
}
html{scroll-behavior:smooth;font-size:16px}
body{font-family:'Outfit',sans-serif;background:var(--bg);color:var(--text);line-height:1.7;-webkit-font-smoothing:antialiased}
::selection{background:var(--accent);color:var(--bg)}
::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-track{background:var(--bg2)}
::-webkit-scrollbar-thumb{background:var(--bg4);border-radius:3px}

/* ── TOP NAV ── */
.topnav{position:fixed;top:0;left:0;right:0;height:56px;background:var(--bg2);border-bottom:1px solid var(--card-border);display:flex;align-items:center;justify-content:space-between;padding:0 24px;z-index:100;backdrop-filter:blur(12px)}
.topnav a{color:var(--text2);text-decoration:none;font-size:.82rem;font-weight:500;transition:color .2s}
.topnav a:hover{color:var(--accent)}
.topnav .nav-center{font-size:.75rem;color:var(--text3);font-weight:600;letter-spacing:1px;text-transform:uppercase}
.topnav .nav-center span{color:var(--accent)}
.topnav .nav-home{color:var(--text3);text-decoration:none;font-size:.82rem;font-weight:500;padding:4px 12px;border:1px solid var(--card-border);border-radius:var(--radius-sm);transition:all .2s;display:inline-flex;align-items:center;gap:4px}
.topnav .nav-home:hover{color:var(--accent);border-color:var(--accent);background:var(--accent-dim)}
.topnav .nav-right{display:flex;align-items:center;gap:12px}

/* ── PROGRESS BAR ── */
.progress-bar{position:fixed;top:56px;left:0;right:0;height:3px;background:var(--bg4);z-index:99}
.progress-bar-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));transition:width .3s;border-radius:0 2px 2px 0}

/* ── MAIN ── */
.main{margin-top:64px;min-height:100vh}
.content{max-width:900px;margin:0 auto;padding:48px 32px 120px}

/* ── SECTIONS ── */
.section{margin-bottom:64px;scroll-margin-top:80px}
.section-num{font-family:'JetBrains Mono',monospace;font-size:.7rem;color:var(--accent);letter-spacing:2px;margin-bottom:8px;display:block}
.section h2{font-size:1.8rem;font-weight:700;letter-spacing:-.01em;margin-bottom:8px;line-height:1.3}
.section-line{width:48px;height:3px;background:var(--accent);border-radius:2px;margin-bottom:28px}
.section h3{font-size:1.15rem;font-weight:600;color:var(--text);margin:32px 0 12px;padding-left:14px;border-left:3px solid var(--accent)}
.section h4{font-size:.95rem;font-weight:600;color:var(--orange);margin:24px 0 8px}
.section p{color:var(--text2);margin-bottom:14px;font-size:.95rem}
.section p strong{color:var(--text);font-weight:600}
.section ul,.section ol{color:var(--text2);margin:8px 0 16px 20px;font-size:.9rem}
.section li{margin-bottom:6px;line-height:1.6}
.section li strong{color:var(--text);font-weight:600}
.section li code{background:var(--bg4);padding:2px 7px;border-radius:4px;font-size:.8rem;color:var(--orange);font-family:'JetBrains Mono',monospace}

/* ── CODE BLOCKS ── */
pre{background:var(--code-bg);border:1px solid var(--code-border);border-radius:var(--radius);padding:20px 24px;overflow-x:auto;margin:16px 0 20px;position:relative}
pre::before{content:attr(data-lang);position:absolute;top:8px;right:12px;font-family:'JetBrains Mono',monospace;font-size:.6rem;color:var(--text3);text-transform:uppercase;letter-spacing:1px;background:var(--bg4);padding:2px 8px;border-radius:4px}
code{font-family:'JetBrains Mono',monospace;font-size:.82rem;line-height:1.6;color:#c5cdd8}
p code,.inline-code{background:var(--bg4);padding:2px 7px;border-radius:4px;font-size:.82rem;color:var(--orange);font-family:'JetBrains Mono',monospace}
.kw{color:#c678dd}.fn{color:#61afef}.str{color:#98c379}.cm{color:#5c6370;font-style:italic}
.num{color:#d19a66}.ann{color:#e5c07b}.tp{color:#e06c75}.op{color:#56b6c2}

/* ── CARDS ── */
.card{background:var(--card);border:1px solid var(--card-border);border-radius:var(--radius);padding:24px;margin:16px 0}
.card-title{font-size:.8rem;font-weight:700;text-transform:uppercase;letter-spacing:1.5px;color:var(--accent);margin-bottom:12px;display:flex;align-items:center;gap:8px}
.card-title::before{content:'';width:8px;height:8px;background:var(--accent);border-radius:50%}
.card.blue .card-title{color:var(--blue)}.card.blue .card-title::before{background:var(--blue)}
.card.purple .card-title{color:var(--purple)}.card.purple .card-title::before{background:var(--purple)}
.card.orange .card-title{color:var(--orange)}.card.orange .card-title::before{background:var(--orange)}

/* ── DIAGRAMS ── */
.diagram{display:flex;align-items:center;justify-content:center;gap:12px;flex-wrap:wrap;margin:20px 0;padding:24px;background:var(--bg3);border-radius:var(--radius);border:1px solid var(--card-border)}
.diagram-box{padding:12px 20px;border-radius:var(--radius-sm);font-size:.8rem;font-weight:600;text-align:center;min-width:120px}
.diagram-box.green{background:rgba(61,214,140,.12);border:1px solid rgba(61,214,140,.3);color:var(--accent)}
.diagram-box.blue{background:rgba(91,156,245,.12);border:1px solid rgba(91,156,245,.3);color:var(--blue)}
.diagram-box.purple{background:rgba(176,122,238,.12);border:1px solid rgba(176,122,238,.3);color:var(--purple)}
.diagram-box.orange{background:rgba(232,145,90,.12);border:1px solid rgba(232,145,90,.3);color:var(--orange)}
.diagram-box.red{background:rgba(224,92,108,.12);border:1px solid rgba(224,92,108,.3);color:var(--red)}
.diagram-box.cyan{background:rgba(86,182,194,.12);border:1px solid rgba(86,182,194,.3);color:var(--cyan)}
.diagram-arrow{color:var(--text3);font-size:1.2rem}

/* ── TIPS ── */
.tip{display:flex;gap:14px;padding:16px 20px;border-radius:var(--radius);margin:16px 0;font-size:.88rem;line-height:1.6}
.tip.good{background:rgba(61,214,140,.06);border:1px solid rgba(61,214,140,.15);color:var(--accent)}
.tip.warn{background:rgba(226,197,90,.06);border:1px solid rgba(226,197,90,.15);color:var(--yellow)}
.tip.info{background:rgba(91,156,245,.06);border:1px solid rgba(91,156,245,.15);color:var(--blue)}
.tip.bad{background:rgba(224,92,108,.06);border:1px solid rgba(224,92,108,.15);color:var(--red)}
.tip-icon{font-size:1.1rem;flex-shrink:0;margin-top:2px}

/* ── Q&A ── */
.qa{background:var(--card);border:1px solid var(--card-border);border-radius:var(--radius);margin:12px 0;overflow:hidden}
.qa-q{padding:16px 20px;font-weight:600;color:var(--text);cursor:pointer;display:flex;align-items:center;gap:10px;font-size:.9rem;transition:background .15s}
.qa-q:hover{background:var(--accent-dim)}
.qa-q::before{content:'Q';font-family:'JetBrains Mono',monospace;font-size:.65rem;background:var(--accent);color:var(--bg);padding:3px 7px;border-radius:4px;font-weight:700}
.qa-a{padding:0 20px 16px 20px;color:var(--text2);font-size:.88rem;display:none}
.qa.open .qa-a{display:block}
.qa.open .qa-q{border-bottom:1px solid var(--card-border)}

/* ── TABLES ── */
.table-wrap{overflow-x:auto;margin:16px 0 20px;border-radius:var(--radius);border:1px solid var(--card-border)}
table{width:100%;border-collapse:collapse;font-size:.85rem}
th{background:var(--bg4);color:var(--accent);font-weight:600;text-transform:uppercase;font-size:.7rem;letter-spacing:1px;padding:12px 16px;text-align:left}
td{padding:10px 16px;border-top:1px solid var(--card-border);color:var(--text2)}
tr:hover td{background:var(--accent-dim)}

/* ── TAGS ── */
.tag-list{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0}
.tag{display:inline-block;padding:4px 12px;background:var(--bg3);border:1px solid var(--card-border);border-radius:16px;font-size:.72rem;color:var(--text2);font-weight:500;transition:all .2s}

/* ── QUIZ ── */
.quiz-section{margin-top:64px;padding-top:32px;border-top:2px solid var(--card-border)}
.quiz-section h3{border-left-color:var(--purple)}
.quiz-card{background:var(--card);border:1px solid var(--card-border);border-radius:var(--radius);padding:24px;margin:16px 0}
.quiz-question{font-weight:600;color:var(--text);margin-bottom:16px;font-size:.92rem;display:flex;gap:10px}
.quiz-question .q-num{font-family:'JetBrains Mono',monospace;color:var(--accent);font-size:.8rem;min-width:28px}
.quiz-options{display:flex;flex-direction:column;gap:8px;margin-bottom:8px}
.quiz-option{display:flex;align-items:center;gap:12px;padding:10px 16px;background:var(--bg3);border:1px solid var(--card-border);border-radius:var(--radius-sm);cursor:pointer;transition:all .2s;font-size:.88rem;color:var(--text2)}
.quiz-option:hover{border-color:var(--accent);background:var(--accent-dim)}
.quiz-option.selected{border-color:var(--accent);background:var(--accent-dim);color:var(--text)}
.quiz-option.correct{border-color:var(--accent);background:rgba(61,214,140,.15);color:var(--accent)}
.quiz-option.wrong{border-color:var(--red);background:rgba(224,92,108,.1);color:var(--red)}
.quiz-option input[type="radio"]{accent-color:var(--accent)}
.quiz-explanation{display:none;padding:12px 16px;background:var(--bg3);border-radius:var(--radius-sm);margin-top:8px;font-size:.82rem;color:var(--text2);border-left:3px solid var(--accent)}
.quiz-explanation.visible{display:block}
.quiz-actions{display:flex;gap:12px;margin-top:24px;flex-wrap:wrap}
.btn{padding:12px 28px;border-radius:var(--radius-sm);font-family:'Outfit',sans-serif;font-size:.88rem;font-weight:600;cursor:pointer;border:none;transition:all .2s}
.btn-primary{background:var(--accent);color:var(--bg)}
.btn-primary:hover{background:var(--accent2)}
.btn-secondary{background:var(--bg3);color:var(--text2);border:1px solid var(--card-border)}
.btn-secondary:hover{border-color:var(--accent);color:var(--accent)}
.btn:disabled{opacity:.4;cursor:not-allowed}
.quiz-result{display:none;padding:24px;background:var(--card);border:1px solid var(--card-border);border-radius:var(--radius);margin-top:24px;text-align:center}
.quiz-result.visible{display:block}
.quiz-score{font-size:2.4rem;font-weight:800;color:var(--accent);margin:8px 0}
.quiz-score.low{color:var(--red)}
.quiz-score.mid{color:var(--yellow)}

/* ── WIZARD NAV ── */
.wizard-nav{display:flex;justify-content:space-between;align-items:center;margin-top:64px;padding:32px 0;border-top:1px solid var(--card-border)}
.wizard-nav a{display:inline-flex;align-items:center;gap:8px;padding:12px 24px;background:var(--bg3);border:1px solid var(--card-border);border-radius:var(--radius-sm);color:var(--text2);text-decoration:none;font-size:.88rem;font-weight:500;transition:all .2s}
.wizard-nav a:hover{border-color:var(--accent);color:var(--accent);background:var(--accent-dim)}
.wizard-nav a.primary{background:var(--accent);color:var(--bg);border-color:var(--accent)}
.wizard-nav a.primary:hover{background:var(--accent2)}
.wizard-nav .wizard-home{display:inline-flex;align-items:center;gap:8px;padding:12px 24px;background:var(--bg3);border:1px solid var(--card-border);border-radius:var(--radius-sm);color:var(--text2);text-decoration:none;font-size:.88rem;font-weight:500;transition:all .2s}
.wizard-nav .wizard-home:hover{border-color:var(--accent);color:var(--accent);background:var(--accent-dim)}

/* ── RESPONSIVE ── */
@media(max-width:768px){
.content{padding:32px 16px 80px}
.topnav{padding:0 12px}
.section h2{font-size:1.4rem}
}

/* ── ANIMATIONS ── */
@keyframes fadeUp{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
.section{animation:fadeUp .5s ease both}
</style>
</head>
<body>

<!-- ── TOP NAVIGATION ── -->
<nav class="topnav">
<a href="22-rest-graphql-grpc-websocket.html">&#8592; Anterior</a>
<div class="nav-center">Seção <span>23</span> / 66</div>
<div class="nav-right"><a href="../fullstack-mastery.html" class="nav-home" title="Voltar ao Dashboard">&#8962; Home</a>
<a href="24-aws-servicos-essenciais.html">Próximo &#8594;</a></div>
</nav>
<div class="progress-bar"><div class="progress-bar-fill" style="width:34.8%"></div></div>

<!-- ── MAIN CONTENT ── -->
<div class="main">
<div class="content">

<div class="section">
<span class="section-num">Seção 23</span>
<h2>API Design — Versionamento &amp; Gateway</h2>
<div class="section-line"></div>

<p>APIs são contratos. Quando você pública uma API, consumidores (frontend, mobile, terceiros) dependem dela. Mudar esse contrato sem cuidado quebra integração de quem depende. Por isso, <strong>versionamento</strong> é a primeira decisão crítica de API design. E quando você tem múltiplos serviços, o <strong>API Gateway</strong> se torna o ponto central de controle — roteamento, autenticação, raté limiting, tudo em um único ponto de entrada.</p>

<p>Nesta seção, cobrimos as estratégias de versionamento, o papel do API Gateway, design API-First com OpenAPI, idempotência, páginação cursor-based, error handling padronizado (RFC 7807), raté limiting, segurança e documentação automática.</p>

<!-- ═══ 1. API VERSIONING ═══ -->
<h3>1. API Versioning</h3>
<p>Existem três abordagens principais para versionar APIs. Cada uma tem trade-offs distintos:</p>

<div class="table-wrap">
<table>
<tr><th>Estratégia</th><th>Exemplo</th><th>Pros</th><th>Contras</th></tr>
<tr><td><strong>URL Path</strong></td><td><code>/api/v1/users</code></td><td>Mais explícita, fácil de rotear, cache-friendly</td><td>URLs mudam, pode duplicar controllers</td></tr>
<tr><td><strong>Header</strong></td><td><code>Accept: application/vnd.api.v2+json</code></td><td>URLs limpas, semânticamente correto</td><td>Difícil de testar no browser, menós visível</td></tr>
<tr><td><strong>Query Param</strong></td><td><code>/api/users?version=2</code></td><td>Simples de implementar</td><td>Fácil de esquecer, poluição de query string</td></tr>
</table>
</div>

<div class="tip good">
<span class="tip-icon">&#10022;</span>
<div><strong>Recomendação da indústria:</strong> URL Path (<code>/api/v1/</code>) é a estratégia mais comum e adotada por Google, Stripe, GitHub, Twitter. É a mais explícita é fácil de depurar. Use-a como padrão a menós que tenha razão forte para não usar.</div>
</div>

<h4>Semantic Versioning para APIs</h4>
<p>APIs seguem um modelo simplificado de semver: <strong>MAJOR</strong> (breaking changes), <strong>MINOR</strong> (features novas backwards-compatible), <strong>PATCH</strong> (bug fixes). Na URL, geralmente só o MAJOR aparece (<code>/v1/</code>, <code>/v2/</code>).</p>

<h4>Breaking vs Non-Breaking Changes</h4>
<ul>
<li><strong>Breaking (exigem nova versão):</strong> remover campo, renomear campo, mudar tipo de campo, alterár formato de resposta, mudar semântica de status code</li>
<li><strong>Non-breaking (podem ir na versão atual):</strong> adicionar campo novo na resposta, adicionar endpoint novo, adicionar query param opcional, adicionar header opcional</li>
</ul>

<h4>Estratégia de Deprecation</h4>
<pre data-lang="typescript"><code><span class="cm">// NestJS — Controller com versionamento e deprecation</span>
<span class="ann">@Controller</span>({ path: <span class="str">'users'</span>, version: <span class="str">'1'</span> })
<span class="kw">export class</span> <span class="tp">UsersV1Controller</span> {
  <span class="ann">@Get</span>()
  <span class="ann">@Header</span>(<span class="str">'Deprecation'</span>, <span class="str">'true'</span>)
  <span class="ann">@Header</span>(<span class="str">'Sunset'</span>, <span class="str">'Sat, 01 Mar 2026 00:00:00 GMT'</span>)
  <span class="ann">@Header</span>(<span class="str">'Link'</span>, <span class="str">'&lt;/api/v2/users&gt;; rel="successor-version"'</span>)
  <span class="fn">findAll</span>() {
    <span class="cm">// Versao antiga — marcada para sunset</span>
    <span class="kw">return</span> <span class="kw">this</span>.usersService.<span class="fn">findAllLegacy</span>();
  }
}

<span class="ann">@Controller</span>({ path: <span class="str">'users'</span>, version: <span class="str">'2'</span> })
<span class="kw">export class</span> <span class="tp">UsersV2Controller</span> {
  <span class="ann">@Get</span>()
  <span class="fn">findAll</span>() {
    <span class="cm">// Versao nova — formato de resposta atualizado</span>
    <span class="kw">return</span> <span class="kw">this</span>.usersService.<span class="fn">findAllV2</span>();
  }
}

<span class="cm">// main.ts — Habilitar versionamento por URL</span>
<span class="kw">const</span> app = <span class="kw">await</span> NestFactory.<span class="fn">create</span>(<span class="tp">AppModule</span>);
app.<span class="fn">enableVersioning</span>({
  type: <span class="tp">VersioningType</span>.URI,
  defaultVersion: <span class="str">'1'</span>,
  prefix: <span class="str">'api/v'</span>,
});</code></pre>

<div class="tip info">
<span class="tip-icon">i</span>
<div><strong>Headers de Deprecation:</strong> Use o header <code>Deprecation: true</code> junto com <code>Sunset</code> (data de desligamento) e <code>Link</code> (URL da nova versão). Isso permite que consumidores se preparem para a migração automáticamente.</div>
</div>

<!-- ═══ 2. API GATEWAY ═══ -->
<h3>2. API Gateway</h3>
<p>O API Gateway é o <strong>ponto único de entrada</strong> para todos os clientes que consomem seus microsserviços. Ele atua como um reverse proxy inteligente, centralizando responsabilidades transversais (cross-cutting concerns) que seriam duplicadas em cada serviço.</p>

<h4>Responsabilidades do Gateway</h4>
<ul>
<li><strong>Roteamento:</strong> direciona requests para o microsserviço correto baseado em path/header</li>
<li><strong>Autenticação/Autorização:</strong> válida JWT/API keys antes de chegar ao serviço</li>
<li><strong>Raté Limiting:</strong> protege serviços de abusó (por IP, por API key, por usuário)</li>
<li><strong>Payload Transformation:</strong> converte formatos (XML &rarr; JSON), adiciona/remove campos</li>
<li><strong>Response Aggregation:</strong> combina respostas de múltiplos serviços em uma única resposta</li>
<li><strong>CORS:</strong> gerência headers de Cross-Origin centralizadamente</li>
<li><strong>Circuit Breaking:</strong> evita cascading failures quando um serviço está fora do ar</li>
<li><strong>Request/Response Logging:</strong> observabilidade centralizada de todas as chamadas</li>
<li><strong>Caching:</strong> cache de respostas para endpoints frequentes e idempotentes</li>
<li><strong>Load Balancing:</strong> distribui carga entre instâncias do mesmo serviço</li>
</ul>

<h4>Arquitetura: Gateway em frente a Microsserviços</h4>
<div class="diagram">
<div class="diagram-box orange">Clients<br><small>Web / Mobile / 3rd Party</small></div>
<div class="diagram-arrow">&rarr;</div>
<div class="diagram-box green">API Gateway<br><small>Auth, Raté Limit, Route</small></div>
<div class="diagram-arrow">&rarr;</div>
<div class="diagram-box blue">Catalog Service</div>
<div class="diagram-box blue">Orders Service</div>
<div class="diagram-box blue">Users Service</div>
<div class="diagram-box blue">Payments Service</div>
</div>

<h4>Ferramentas Populares</h4>
<div class="table-wrap">
<table>
<tr><th>Ferramenta</th><th>Tipo</th><th>Destaque</th></tr>
<tr><td><strong>Kong</strong></td><td>Open-source / Enterprise</td><td>Plugins extensíveis, Lua/Go, alta performance</td></tr>
<tr><td><strong>AWS API Gateway</strong></td><td>Managed (cloud)</td><td>Integra com Lambda, IAM, CloudWatch nativamente</td></tr>
<tr><td><strong>Apigee</strong></td><td>Enterprise (Google)</td><td>Analytics avançado, developer portal</td></tr>
<tr><td><strong>Traefik</strong></td><td>Open-source</td><td>Auto-discovery com Docker/K8s, config dinâmica</td></tr>
<tr><td><strong>NGINX</strong></td><td>Open-source</td><td>Alta performance, configuração declarativa</td></tr>
<tr><td><strong>Envoy</strong></td><td>Open-source (CNCF)</td><td>Service mesh, observabilidade L7, gRPC nativo</td></tr>
</table>
</div>

<h4>Kong — Configuração Exemplo</h4>
<pre data-lang="yaml"><code><span class="cm"># kong.yml — Declarative config</span>
<span class="tp">_format_version</span>: <span class="str">"3.0"</span>

<span class="tp">services</span>:
  - <span class="tp">name</span>: <span class="str">catalog-service</span>
    <span class="tp">url</span>: <span class="str">http://catalog:3001</span>
    <span class="tp">routes</span>:
      - <span class="tp">name</span>: <span class="str">catalog-route</span>
        <span class="tp">paths</span>:
          - <span class="str">/api/v1/catalog</span>
        <span class="tp">strip_path</span>: <span class="num">false</span>
    <span class="tp">plugins</span>:
      - <span class="tp">name</span>: <span class="str">rate-limiting</span>
        <span class="tp">config</span>:
          <span class="tp">minute</span>: <span class="num">100</span>
          <span class="tp">policy</span>: <span class="str">redis</span>
      - <span class="tp">name</span>: <span class="str">jwt</span>
      - <span class="tp">name</span>: <span class="str">cors</span>
        <span class="tp">config</span>:
          <span class="tp">origins</span>: [<span class="str">"https://app.example.com"</span>]
          <span class="tp">methods</span>: [<span class="str">"GET"</span>, <span class="str">"POST"</span>, <span class="str">"PUT"</span>, <span class="str">"DELETE"</span>]

  - <span class="tp">name</span>: <span class="str">orders-service</span>
    <span class="tp">url</span>: <span class="str">http://orders:3002</span>
    <span class="tp">routes</span>:
      - <span class="tp">name</span>: <span class="str">orders-route</span>
        <span class="tp">paths</span>:
          - <span class="str">/api/v1/orders</span></code></pre>

<h4>AWS API Gateway — REST API com Lambda</h4>
<pre data-lang="yaml"><code><span class="cm"># serverless.yml (Serverless Framework)</span>
<span class="tp">functions</span>:
  <span class="tp">getUsers</span>:
    <span class="tp">handler</span>: <span class="str">src/handlers/users.getAll</span>
    <span class="tp">events</span>:
      - <span class="tp">http</span>:
          <span class="tp">path</span>: <span class="str">/api/v1/users</span>
          <span class="tp">method</span>: <span class="str">get</span>
          <span class="tp">cors</span>: <span class="num">true</span>
          <span class="tp">authorizer</span>:
            <span class="tp">name</span>: <span class="str">jwtAuthorizer</span>
            <span class="tp">type</span>: <span class="str">TOKEN</span>
            <span class="tp">identitySource</span>: <span class="str">method.request.header.Authorization</span>

  <span class="tp">createOrder</span>:
    <span class="tp">handler</span>: <span class="str">src/handlers/orders.create</span>
    <span class="tp">events</span>:
      - <span class="tp">http</span>:
          <span class="tp">path</span>: <span class="str">/api/v1/orders</span>
          <span class="tp">method</span>: <span class="str">post</span>
          <span class="tp">cors</span>: <span class="num">true</span>
          <span class="tp">authorizer</span>: <span class="str">jwtAuthorizer</span>
          <span class="tp">throttle</span>:
            <span class="tp">burstLimit</span>: <span class="num">50</span>
            <span class="tp">rateLimit</span>: <span class="num">100</span></code></pre>

<!-- ═══ 3. API-FIRST DESIGN ═══ -->
<h3>3. API-First Design</h3>
<p>API-First significa <strong>projetar o contrato da API antes de implementar qualquer código</strong>. O spec (OpenAPI/Swagger) vira a fonte de verdade. Frontend e backend podem trabalhar em paralelo: frontend usa mocks gerados do spec, backend implementa contra o contrato.</p>

<h4>OpenAPI 3.0 — Spec Exemplo</h4>
<pre data-lang="yaml"><code><span class="tp">openapi</span>: <span class="str">"3.0.3"</span>
<span class="tp">info</span>:
  <span class="tp">title</span>: <span class="str">E-Commerce API</span>
  <span class="tp">version</span>: <span class="str">"1.0.0"</span>
  <span class="tp">description</span>: <span class="str">API para gerenciamento de pedidos e produtos</span>

<span class="tp">servers</span>:
  - <span class="tp">url</span>: <span class="str">https://api.example.com/v1</span>
    <span class="tp">description</span>: <span class="str">Production</span>
  - <span class="tp">url</span>: <span class="str">http://localhost:3000/v1</span>
    <span class="tp">description</span>: <span class="str">Development</span>

<span class="tp">paths</span>:
  <span class="tp">/products</span>:
    <span class="tp">get</span>:
      <span class="tp">summary</span>: <span class="str">Listar produtos com páginação cursor-based</span>
      <span class="tp">operationId</span>: <span class="str">listProducts</span>
      <span class="tp">tags</span>: [<span class="str">Products</span>]
      <span class="tp">parameters</span>:
        - <span class="tp">name</span>: <span class="str">cursor</span>
          <span class="tp">in</span>: <span class="str">query</span>
          <span class="tp">schema</span>: { <span class="tp">type</span>: <span class="str">string</span> }
        - <span class="tp">name</span>: <span class="str">limit</span>
          <span class="tp">in</span>: <span class="str">query</span>
          <span class="tp">schema</span>: { <span class="tp">type</span>: <span class="str">integer</span>, <span class="tp">default</span>: <span class="num">20</span>, <span class="tp">maximum</span>: <span class="num">100</span> }
      <span class="tp">responses</span>:
        <span class="str">"200"</span>:
          <span class="tp">description</span>: <span class="str">Lista páginada de produtos</span>
          <span class="tp">content</span>:
            <span class="tp">application/json</span>:
              <span class="tp">schema</span>:
                <span class="tp">$ref</span>: <span class="str">"#/components/schemas/PaginatedProducts"</span>
        <span class="str">"429"</span>:
          <span class="tp">description</span>: <span class="str">Raté limit excedido</span>
          <span class="tp">headers</span>:
            <span class="tp">Retry-After</span>:
              <span class="tp">schema</span>: { <span class="tp">type</span>: <span class="str">integer</span> }

<span class="tp">components</span>:
  <span class="tp">schemas</span>:
    <span class="tp">Product</span>:
      <span class="tp">type</span>: <span class="str">object</span>
      <span class="tp">required</span>: [<span class="str">id</span>, <span class="str">name</span>, <span class="str">price</span>]
      <span class="tp">properties</span>:
        <span class="tp">id</span>: { <span class="tp">type</span>: <span class="str">string</span>, <span class="tp">format</span>: <span class="str">uuid</span> }
        <span class="tp">name</span>: { <span class="tp">type</span>: <span class="str">string</span>, <span class="tp">maxLength</span>: <span class="num">200</span> }
        <span class="tp">price</span>: { <span class="tp">type</span>: <span class="str">number</span>, <span class="tp">minimum</span>: <span class="num">0</span> }
        <span class="tp">createdAt</span>: { <span class="tp">type</span>: <span class="str">string</span>, <span class="tp">format</span>: <span class="str">date-time</span> }</code></pre>

<h4>Code Generation a partir do Spec</h4>
<ul>
<li><strong>openapi-generator:</strong> gera clients (TypeScript, Python, Java) é server stubs automáticamente</li>
<li><strong>orval:</strong> gera React Query hooks a partir do OpenAPI spec — usado em projetos modernós com TanStack Query</li>
<li><strong>swagger-typescript-api:</strong> gera types + API client TypeScript</li>
</ul>

<pre data-lang="bash"><code><span class="cm"># Gerar client TypeScript a partir do spec</span>
npx openapi-generator-cli generaté \
  -i openapi.yaml \
  -g typescript-axios \
  -o src/generated/api

<span class="cm"># Gerar React Query hooks com orval</span>
npx orval --input openapi.yaml --output src/api/generated.ts</code></pre>

<h4>Consumer-Driven Contracts</h4>
<p>Em vez de o provider definir o contrato sozinho, o <strong>consumidor</strong> declara o que precisa (quais campos, quais endpoints). Ferramentas como <strong>Pact</strong> permitem que testes do consumidor gerem contratos que o provider válida. Se o provider quebrar um contrato, o teste falha antes do deploy.</p>

<!-- ═══ 4. IDEMPOTENCY ═══ -->
<h3>4. Idempotência</h3>
<p>GET, PUT e DELETE são naturalmente idempotentes — chamar 2x produz o mesmo resultado. Mas <strong>POST não e</strong>. Se o cliente envia um POST para criar um pedido é a rede falha após o servidor processar (mas antes da resposta chegar), o cliente não sabe se deu certo. Ele reenvia — e agora tem 2 pedidos duplicados.</p>

<p>A solução é o <strong>Idempotency Key</strong>: o cliente gera um UUID único e envia no header. O servidor armazena o resultado associado a essa key. Se receber a mesma key de novo, retorna o resultado armazenado sem reprocessar.</p>

<h4>Implementação com Redis</h4>
<pre data-lang="typescript"><code><span class="cm">// idempotency.middleware.ts — NestJS Middleware</span>
<span class="kw">import</span> { <span class="tp">Injectable</span>, <span class="tp">NestMiddleware</span> } <span class="kw">from</span> <span class="str">'@nestjs/common'</span>;
<span class="kw">import</span> { <span class="tp">Redis</span> } <span class="kw">from</span> <span class="str">'ioredis'</span>;

<span class="ann">@Injectable</span>()
<span class="kw">export class</span> <span class="tp">IdempotencyMiddleware</span> <span class="kw">implements</span> <span class="tp">NestMiddleware</span> {
  <span class="kw">private</span> <span class="kw">readonly</span> TTL = <span class="num">86400</span>; <span class="cm">// 24h em segundos</span>

  <span class="kw">constructor</span>(<span class="kw">private</span> <span class="kw">readonly</span> redis: <span class="tp">Redis</span>) {}

  <span class="kw">async</span> <span class="fn">use</span>(req: <span class="tp">Request</span>, res: <span class="tp">Response</span>, next: <span class="tp">NextFunction</span>) {
    <span class="cm">// So aplica a POST (GET/PUT/DELETE já são idempotentes)</span>
    <span class="kw">if</span> (req.method !== <span class="str">'POST'</span>) <span class="kw">return</span> <span class="fn">next</span>();

    <span class="kw">const</span> idempotencyKey = req.headers[<span class="str">'idempotency-key'</span>];
    <span class="kw">if</span> (!idempotencyKey) <span class="kw">return</span> <span class="fn">next</span>();

    <span class="kw">const</span> cacheKey = <span class="str">`idempotency:${idempotencyKey}`</span>;

    <span class="cm">// 1. Verificar se já temos resultado armazenado</span>
    <span class="kw">const</span> cached = <span class="kw">await</span> <span class="kw">this</span>.redis.<span class="fn">get</span>(cacheKey);
    <span class="kw">if</span> (cached) {
      <span class="kw">const</span> { statusCode, body } = JSON.<span class="fn">parse</span>(cached);
      res.<span class="fn">status</span>(statusCode).<span class="fn">json</span>(body);
      <span class="kw">return</span>;
    }

    <span class="cm">// 2. Tentar adquirir lock (evitar race condition)</span>
    <span class="kw">const</span> lockKey = <span class="str">`lock:${idempotencyKey}`</span>;
    <span class="kw">const</span> acquired = <span class="kw">await</span> <span class="kw">this</span>.redis.<span class="fn">set</span>(lockKey, <span class="str">'1'</span>, <span class="str">'EX'</span>, <span class="num">30</span>, <span class="str">'NX'</span>);
    <span class="kw">if</span> (!acquired) {
      res.<span class="fn">status</span>(<span class="num">409</span>).<span class="fn">json</span>({ error: <span class="str">'Request in progress'</span> });
      <span class="kw">return</span>;
    }

    <span class="cm">// 3. Interceptar a resposta para armazenar</span>
    <span class="kw">const</span> originalJson = res.json.<span class="fn">bind</span>(res);
    res.json = (body: <span class="tp">any</span>) => {
      <span class="kw">const</span> result = { statusCode: res.statusCode, body };
      <span class="kw">this</span>.redis.<span class="fn">set</span>(cacheKey, JSON.<span class="fn">stringify</span>(result), <span class="str">'EX'</span>, <span class="kw">this</span>.TTL);
      <span class="kw">this</span>.redis.<span class="fn">del</span>(lockKey);
      <span class="kw">return</span> <span class="fn">originalJson</span>(body);
    };

    <span class="fn">next</span>();
  }
}</code></pre>

<div class="tip info">
<span class="tip-icon">i</span>
<div><strong>Abordagem Stripe:</strong> Stripe usa <code>Idempotency-Key</code> header em todos os POST. O cliente gera um UUID v4 e reenvia o mesmo se precisar de retry. O resultado fica cacheado por 24h. Essa abordagem é o padrão da indústria para APIs financeiras.</div>
</div>

<!-- ═══ 5. PAGINATION ═══ -->
<h3>5. Paginação — Cursor-Based</h3>
<p>Paginação offset-based (<code>?page=5&limit=20</code>) tem problemas em datasets grandes: performance degrada com offsets altos (o banco precisa contar N rows para pular) e dados podem ser duplicados/perdidos quando novos itens são inseridos durante a navegação. <strong>Cursor-based</strong> resolve ambos os problemas.</p>

<h4>Implementação TypeScript</h4>
<pre data-lang="typescript"><code><span class="cm">// Cursor-based págination — NestJS + TypeORM</span>
<span class="kw">interface</span> <span class="tp">PaginatedResponse</span>&lt;<span class="tp">T</span>&gt; {
  data: <span class="tp">T</span>[];
  meta: {
    cursor: <span class="tp">string</span> | <span class="kw">null</span>;
    hasMore: <span class="tp">boolean</span>;
    count: <span class="tp">number</span>;
  };
}

<span class="ann">@Injectable</span>()
<span class="kw">export class</span> <span class="tp">ProductsService</span> {
  <span class="kw">async</span> <span class="fn">findAll</span>(
    cursor?: <span class="tp">string</span>,
    limit: <span class="tp">number</span> = <span class="num">20</span>,
  ): <span class="tp">Promise</span>&lt;<span class="tp">PaginatedResponse</span>&lt;<span class="tp">Product</span>&gt;&gt; {
    <span class="kw">const</span> qb = <span class="kw">this</span>.repo
      .<span class="fn">createQueryBuilder</span>(<span class="str">'p'</span>)
      .<span class="fn">orderBy</span>(<span class="str">'p.createdAt'</span>, <span class="str">'DESC'</span>)
      .<span class="fn">addOrderBy</span>(<span class="str">'p.id'</span>, <span class="str">'DESC'</span>)
      .<span class="fn">take</span>(limit + <span class="num">1</span>); <span class="cm">// +1 para saber se tem mais</span>

    <span class="kw">if</span> (cursor) {
      <span class="kw">const</span> decoded = JSON.<span class="fn">parse</span>(
        Buffer.<span class="fn">from</span>(cursor, <span class="str">'base64'</span>).<span class="fn">toString</span>(),
      );
      qb.<span class="fn">where</span>(
        <span class="str">'(p.createdAt, p.id) &lt; (:date, :id)'</span>,
        { date: decoded.createdAt, id: decoded.id },
      );
    }

    <span class="kw">const</span> items = <span class="kw">await</span> qb.<span class="fn">getMany</span>();
    <span class="kw">const</span> hasMore = items.length > limit;
    <span class="kw">if</span> (hasMore) items.<span class="fn">pop</span>(); <span class="cm">// Remove o item extra</span>

    <span class="kw">const</span> lastItem = items[items.length - <span class="num">1</span>];
    <span class="kw">const</span> nextCursor = hasMore && lastItem
      ? Buffer.<span class="fn">from</span>(JSON.<span class="fn">stringify</span>({
          createdAt: lastItem.createdAt,
          id: lastItem.id,
        })).<span class="fn">toString</span>(<span class="str">'base64'</span>)
      : <span class="kw">null</span>;

    <span class="kw">return</span> {
      data: items,
      meta: { cursor: nextCursor, hasMore, count: items.length },
    };
  }
}</code></pre>

<div class="card">
<div class="card-title">Formato de Resposta Padrão</div>
<pre data-lang="json"><code>{
  <span class="str">"data"</span>: [
    { <span class="str">"id"</span>: <span class="str">"abc-123"</span>, <span class="str">"name"</span>: <span class="str">"Produto A"</span>, <span class="str">"price"</span>: <span class="num">99.90</span> },
    { <span class="str">"id"</span>: <span class="str">"abc-124"</span>, <span class="str">"name"</span>: <span class="str">"Produto B"</span>, <span class="str">"price"</span>: <span class="num">149.90</span> }
  ],
  <span class="str">"meta"</span>: {
    <span class="str">"cursor"</span>: <span class="str">"eyJjcmVhdGVkQXQiOiIyMDI1LTAxLTE1IiwiaWQiOiJhYmMtMTI0In0="</span>,
    <span class="str">"hasMore"</span>: <span class="kw">true</span>,
    <span class="str">"count"</span>: <span class="num">20</span>
  }
}</code></pre>
</div>

<!-- ═══ 6. ERROR HANDLING ═══ -->
<h3>6. Error Handling — RFC 7807 Problem Details</h3>
<p>A <strong>RFC 7807</strong> define um formato padrão para erros em APIs HTTP. Ao inves de cada API inventar seu próprio formato, todos usam a mesma estrutura. Isso permite que clients genéricos tratem erros de qualquer API da mesma forma.</p>

<h4>Formato Problem Details</h4>
<pre data-lang="json"><code>{
  <span class="str">"type"</span>: <span class="str">"https://api.example.com/errors/válidation"</span>,
  <span class="str">"title"</span>: <span class="str">"Validation Error"</span>,
  <span class="str">"status"</span>: <span class="num">422</span>,
  <span class="str">"detail"</span>: <span class="str">"O campo 'email' deve ser um endereço de email válido."</span>,
  <span class="str">"instance"</span>: <span class="str">"/api/v1/users"</span>,
  <span class="str">"errors"</span>: [
    { <span class="str">"field"</span>: <span class="str">"email"</span>, <span class="str">"message"</span>: <span class="str">"Must be a valid email address"</span> },
    { <span class="str">"field"</span>: <span class="str">"name"</span>, <span class="str">"message"</span>: <span class="str">"Must be at least 2 characters"</span> }
  ],
  <span class="str">"traceId"</span>: <span class="str">"req-abc-123-def-456"</span>
}</code></pre>

<h4>NestJS Exception Filter — Implementação Completa</h4>
<pre data-lang="typescript"><code><span class="cm">// problem-details.filter.ts</span>
<span class="kw">import</span> {
  <span class="tp">ExceptionFilter</span>, <span class="tp">Catch</span>, <span class="tp">ArgumentsHost</span>,
  <span class="tp">HttpException</span>, <span class="tp">HttpStatus</span>,
} <span class="kw">from</span> <span class="str">'@nestjs/common'</span>;
<span class="kw">import</span> { randomUUID } <span class="kw">from</span> <span class="str">'crypto'</span>;

<span class="ann">@Catch</span>()
<span class="kw">export class</span> <span class="tp">ProblemDetailsFilter</span> <span class="kw">implements</span> <span class="tp">ExceptionFilter</span> {
  <span class="fn">catch</span>(exception: <span class="tp">unknown</span>, host: <span class="tp">ArgumentsHost</span>) {
    <span class="kw">const</span> ctx = host.<span class="fn">switchToHttp</span>();
    <span class="kw">const</span> res = ctx.<span class="fn">getResponse</span>();
    <span class="kw">const</span> req = ctx.<span class="fn">getRequest</span>();

    <span class="kw">let</span> status = <span class="tp">HttpStatus</span>.INTERNAL_SERVER_ERROR;
    <span class="kw">let</span> title = <span class="str">'Internal Server Error'</span>;
    <span class="kw">let</span> detail = <span class="str">'An unexpected error occurred'</span>;
    <span class="kw">let</span> errors: <span class="tp">any</span>[] = [];

    <span class="kw">if</span> (exception <span class="kw">instanceof</span> <span class="tp">HttpException</span>) {
      status = exception.<span class="fn">getStatus</span>();
      <span class="kw">const</span> response = exception.<span class="fn">getResponse</span>() <span class="kw">as</span> <span class="tp">any</span>;
      title = response.error || exception.message;
      detail = response.message || exception.message;

      <span class="cm">// ValidationPipe retorna array de mensagens</span>
      <span class="kw">if</span> (Array.<span class="fn">isArray</span>(response.message)) {
        errors = response.message.<span class="fn">map</span>((msg: <span class="tp">string</span>) => ({
          field: msg.<span class="fn">split</span>(<span class="str">' '</span>)[<span class="num">0</span>],
          message: msg,
        }));
        detail = <span class="str">'Validation failed'</span>;
      }
    }

    <span class="kw">const</span> problemDetails = {
      type: <span class="str">`https://api.example.com/errors/${status}`</span>,
      title,
      status,
      detail,
      instance: req.url,
      ...(errors.length > <span class="num">0</span> && { errors }),
      traceId: <span class="fn">randomUUID</span>(),
      timestamp: <span class="kw">new</span> <span class="tp">Date</span>().<span class="fn">toISOString</span>(),
    };

    res.<span class="fn">status</span>(status).<span class="fn">json</span>(problemDetails);
  }
}</code></pre>

<h4>HTTP Status Code — Árvore de Decisão</h4>
<div class="table-wrap">
<table>
<tr><th>Cenário</th><th>Status</th><th>Quando usar</th></tr>
<tr><td>Sucessó com body</td><td><code>200 OK</code></td><td>GET, PUT, PATCH com resposta</td></tr>
<tr><td>Recursó criado</td><td><code>201 Created</code></td><td>POST que cria algo (retornar Location header)</td></tr>
<tr><td>Sucessó sem body</td><td><code>204 No Content</code></td><td>DELETE bem-sucedido</td></tr>
<tr><td>Input inválido</td><td><code>400 Bad Request</code></td><td>JSON malformado, campos faltando</td></tr>
<tr><td>Não autenticado</td><td><code>401 Unauthorized</code></td><td>Token ausente ou expirado</td></tr>
<tr><td>Sem permissão</td><td><code>403 Forbidden</code></td><td>Autenticado mas sem acesso</td></tr>
<tr><td>Não encontrado</td><td><code>404 Not Found</code></td><td>Recursó não existe</td></tr>
<tr><td>Conflito</td><td><code>409 Conflict</code></td><td>Duplicata, estado inconsistente</td></tr>
<tr><td>Validação semântica</td><td><code>422 Unprocessable Entity</code></td><td>JSON válido mas dados inválidos</td></tr>
<tr><td>Raté limit</td><td><code>429 Too Many Requests</code></td><td>Excedeu limite (enviar Retry-After)</td></tr>
<tr><td>Erro do servidor</td><td><code>500 Internal Server Error</code></td><td>Bug inesperado, exceptions não tratadas</td></tr>
<tr><td>Serviço indisponível</td><td><code>503 Service Unavailable</code></td><td>Manutenção, dependência fora do ar</td></tr>
</table>
</div>

<!-- ═══ 7. RATE LIMITING ═══ -->
<h3>7. Raté Limiting no Nível da API</h3>
<p>Raté limiting protege sua API de abuso, garante fairness entre consumidores e evita que um único cliente derrube o serviço. Pode ser aplicado <strong>por IP</strong>, <strong>por usuário autenticado</strong> ou <strong>por API key</strong>.</p>

<h4>Headers de Raté Limit (RFC 6585)</h4>
<ul>
<li><code>X-RateLimit-Limit</code> — total de requests permitidos na janela</li>
<li><code>X-RateLimit-Remaining</code> — requests restantes na janela atual</li>
<li><code>X-RateLimit-Reset</code> — timestamp (epoch) de quando a janela reseta</li>
<li><code>Retry-After</code> — segundos até poder tentar novamente (enviado com 429)</li>
</ul>

<h4>NestJS Throttler — Configuração</h4>
<pre data-lang="typescript"><code><span class="cm">// app.module.ts — Configuração global</span>
<span class="kw">import</span> { <span class="tp">ThrottlerModule</span>, <span class="tp">ThrottlerGuard</span> } <span class="kw">from</span> <span class="str">'@nestjs/throttler'</span>;

<span class="ann">@Module</span>({
  imports: [
    <span class="tp">ThrottlerModule</span>.<span class="fn">forRoot</span>([
      {
        name: <span class="str">'short'</span>,
        ttl: <span class="num">1000</span>,   <span class="cm">// 1 segundo</span>
        limit: <span class="num">3</span>,     <span class="cm">// max 3 requests/segundo</span>
      },
      {
        name: <span class="str">'medium'</span>,
        ttl: <span class="num">60000</span>,  <span class="cm">// 1 minuto</span>
        limit: <span class="num">60</span>,    <span class="cm">// max 60 requests/minuto</span>
      },
      {
        name: <span class="str">'long'</span>,
        ttl: <span class="num">3600000</span>, <span class="cm">// 1 hora</span>
        limit: <span class="num">1000</span>,  <span class="cm">// max 1000 requests/hora</span>
      },
    ]),
  ],
  providers: [
    { provide: <span class="str">'APP_GUARD'</span>, useClass: <span class="tp">ThrottlerGuard</span> },
  ],
})
<span class="kw">export class</span> <span class="tp">AppModule</span> {}

<span class="cm">// Override por rota — endpoints sensiveis</span>
<span class="ann">@Controller</span>(<span class="str">'auth'</span>)
<span class="kw">export class</span> <span class="tp">AuthController</span> {
  <span class="ann">@Post</span>(<span class="str">'login'</span>)
  <span class="ann">@Throttle</span>({ short: { ttl: <span class="num">60000</span>, limit: <span class="num">5</span> } }) <span class="cm">// 5 tentativas/minuto</span>
  <span class="fn">login</span>() { <span class="cm">/* ... */</span> }

  <span class="ann">@Post</span>(<span class="str">'forgot-password'</span>)
  <span class="ann">@Throttle</span>({ short: { ttl: <span class="num">3600000</span>, limit: <span class="num">3</span> } }) <span class="cm">// 3 tentativas/hora</span>
  <span class="fn">forgotPassword</span>() { <span class="cm">/* ... */</span> }
}

<span class="cm">// Endpoint publico sem raté limit</span>
<span class="ann">@Get</span>(<span class="str">'health'</span>)
<span class="ann">@SkipThrottle</span>()
<span class="fn">healthCheck</span>() { <span class="kw">return</span> { status: <span class="str">'ok'</span> }; }</code></pre>

<div class="tip warn">
<span class="tip-icon">&#9888;</span>
<div><strong>Raté Limiting em produção:</strong> O throttler in-memory do NestJS funciona para uma única instância. Em produção com múltiplas instâncias, use Redis como storage compartilhado (via <code>ThrottlerStorageRedisService</code>) para que o limite sejá global.</div>
</div>

<!-- ═══ 8. API SECURITY ═══ -->
<h3>8. Segurança de APIs</h3>
<p>APIs expostas na internet são alvos constantes. A segurança deve ser pensada em <strong>camadas</strong>: autenticação, autorização, validação de input, criptografia em transito e assinatura de requests.</p>

<h4>Camadas de Segurança</h4>
<ul>
<li><strong>TLS (HTTPS):</strong> obrigatório em produção — protege dados em transito. Nunca aceite HTTP para APIs que trafegam dados sensíveis</li>
<li><strong>Autenticação:</strong> API Keys (simples, sem estado), OAuth2 tokens (acesso delegado), JWT (stateless, com claims)</li>
<li><strong>Autorização:</strong> RBAC (Role-Based), ABAC (Attribute-Based), Scopes em OAuth2</li>
<li><strong>Input Validation:</strong> validar TODOS os inputs. Nunca confiar no cliente. Use class-válidator, zod ou joi</li>
<li><strong>Request Signing (HMAC):</strong> garante integridade — o payload não foi alterádo em transito</li>
</ul>

<h4>Request Signing com HMAC</h4>
<pre data-lang="typescript"><code><span class="cm">// hmac-guard.ts — Verificar assinatura HMAC de webhooks</span>
<span class="kw">import</span> { createHmac } <span class="kw">from</span> <span class="str">'crypto'</span>;
<span class="kw">import</span> { <span class="tp">CanActivate</span>, <span class="tp">ExecutionContext</span>, <span class="tp">Injectable</span> } <span class="kw">from</span> <span class="str">'@nestjs/common'</span>;

<span class="ann">@Injectable</span>()
<span class="kw">export class</span> <span class="tp">HmacGuard</span> <span class="kw">implements</span> <span class="tp">CanActivate</span> {
  <span class="kw">privaté readonly</span> secret = process.env.WEBHOOK_SECRET;

  <span class="fn">canActivate</span>(context: <span class="tp">ExecutionContext</span>): <span class="tp">boolean</span> {
    <span class="kw">const</span> req = context.<span class="fn">switchToHttp</span>().<span class="fn">getRequest</span>();
    <span class="kw">const</span> signature = req.headers[<span class="str">'x-signature-256'</span>];
    <span class="kw">if</span> (!signature) <span class="kw">return false</span>;

    <span class="kw">const</span> body = JSON.<span class="fn">stringify</span>(req.body);
    <span class="kw">const</span> expected = <span class="str">'sha256='</span> +
      <span class="fn">createHmac</span>(<span class="str">'sha256'</span>, <span class="kw">this</span>.secret)
        .<span class="fn">update</span>(body)
        .<span class="fn">digest</span>(<span class="str">'hex'</span>);

    <span class="cm">// Comparacao timing-safe para evitar timing attacks</span>
    <span class="kw">const</span> sigBuf = Buffer.<span class="fn">from</span>(signature);
    <span class="kw">const</span> expBuf = Buffer.<span class="fn">from</span>(expected);
    <span class="kw">if</span> (sigBuf.length !== expBuf.length) <span class="kw">return false</span>;

    <span class="kw">return</span> require(<span class="str">'crypto'</span>).<span class="fn">timingSafeEqual</span>(sigBuf, expBuf);
  }
}

<span class="cm">// Usó no controller</span>
<span class="ann">@Post</span>(<span class="str">'webhook'</span>)
<span class="ann">@UseGuards</span>(<span class="tp">HmacGuard</span>)
<span class="fn">handleWebhook</span>(<span class="ann">@Body</span>() payload: <span class="tp">WebhookPayload</span>) {
  <span class="cm">// Payload verificado — seguro para processar</span>
}</code></pre>

<h4>API Key com Scopes</h4>
<pre data-lang="typescript"><code><span class="cm">// api-key.guard.ts</span>
<span class="ann">@Injectable</span>()
<span class="kw">export class</span> <span class="tp">ApiKeyGuard</span> <span class="kw">implements</span> <span class="tp">CanActivate</span> {
  <span class="kw">constructor</span>(<span class="kw">private</span> apiKeyService: <span class="tp">ApiKeyService</span>) {}

  <span class="kw">async</span> <span class="fn">canActivate</span>(ctx: <span class="tp">ExecutionContext</span>): <span class="tp">Promise</span>&lt;<span class="tp">boolean</span>&gt; {
    <span class="kw">const</span> req = ctx.<span class="fn">switchToHttp</span>().<span class="fn">getRequest</span>();
    <span class="kw">const</span> apiKey = req.headers[<span class="str">'x-api-key'</span>];
    <span class="kw">if</span> (!apiKey) <span class="kw">return false</span>;

    <span class="cm">// Buscar key no banco (hasheada com SHA-256)</span>
    <span class="kw">const</span> key = <span class="kw">await</span> <span class="kw">this</span>.apiKeyService.<span class="fn">válidate</span>(apiKey);
    <span class="kw">if</span> (!key || key.revokedAt) <span class="kw">return false</span>;

    <span class="cm">// Verificar scopes</span>
    <span class="kw">const</span> requiredScopes = Reflect.<span class="fn">getMetadata</span>(<span class="str">'scopes'</span>, ctx.<span class="fn">getHandler</span>());
    <span class="kw">if</span> (requiredScopes) {
      <span class="kw">const</span> hasScopes = requiredScopes.<span class="fn">every</span>(
        (s: <span class="tp">string</span>) => key.scopes.<span class="fn">includes</span>(s),
      );
      <span class="kw">if</span> (!hasScopes) <span class="kw">return false</span>;
    }

    req.apiKey = key; <span class="cm">// Disponível nós handlers</span>
    <span class="kw">return true</span>;
  }
}</code></pre>

<!-- ═══ 9. DOCUMENTATION ═══ -->
<h3>9. Documentação de APIs</h3>
<p>Uma API sem documentação é uma API que ninguém consegue usar. As melhores ferramentas geram documentação <strong>automáticamente</strong> a partir de decorators/annotations no código — garantindo que a doc nunca fica desatualizada.</p>

<h4>Ferramentas</h4>
<ul>
<li><strong>Swagger UI:</strong> UI interátiva gerada a partir do OpenAPI spec — permite testar endpoints no browser</li>
<li><strong>Redoc:</strong> documentação limpa e responsiva — ideal para developers portals públicos</li>
<li><strong>Postman Collections:</strong> exportar collections para que consumidores importem e testem</li>
</ul>

<h4>NestJS Swagger — Auto-Generacao</h4>
<pre data-lang="typescript"><code><span class="cm">// main.ts — Setup Swagger</span>
<span class="kw">import</span> { <span class="tp">SwaggerModule</span>, <span class="tp">DocumentBuilder</span> } <span class="kw">from</span> <span class="str">'@nestjs/swagger'</span>;

<span class="kw">const</span> config = <span class="kw">new</span> <span class="tp">DocumentBuilder</span>()
  .<span class="fn">setTitle</span>(<span class="str">'E-Commerce API'</span>)
  .<span class="fn">setDescription</span>(<span class="str">'API para gerenciamento de pedidos'</span>)
  .<span class="fn">setVersion</span>(<span class="str">'1.0'</span>)
  .<span class="fn">addBearerAuth</span>()
  .<span class="fn">addApiKey</span>({ type: <span class="str">'apiKey'</span>, name: <span class="str">'x-api-key'</span>, in: <span class="str">'header'</span> })
  .<span class="fn">build</span>();

<span class="kw">const</span> document = <span class="tp">SwaggerModule</span>.<span class="fn">createDocument</span>(app, config);
<span class="tp">SwaggerModule</span>.<span class="fn">setup</span>(<span class="str">'docs'</span>, app, document);

<span class="cm">// Controller com decorators para documentação automática</span>
<span class="ann">@ApiTags</span>(<span class="str">'Products'</span>)
<span class="ann">@Controller</span>(<span class="str">'products'</span>)
<span class="kw">export class</span> <span class="tp">ProductsController</span> {
  <span class="ann">@Get</span>()
  <span class="ann">@ApiOperation</span>({ summary: <span class="str">'Listar produtos'</span> })
  <span class="ann">@ApiQuery</span>({ name: <span class="str">'cursor'</span>, required: <span class="kw">false</span>, type: <span class="tp">String</span> })
  <span class="ann">@ApiQuery</span>({ name: <span class="str">'limit'</span>, required: <span class="kw">false</span>, type: <span class="tp">Number</span> })
  <span class="ann">@ApiResponse</span>({ status: <span class="num">200</span>, type: <span class="tp">PaginatedProductsDto</span> })
  <span class="ann">@ApiResponse</span>({ status: <span class="num">429</span>, description: <span class="str">'Raté limit excedido'</span> })
  <span class="fn">findAll</span>(<span class="ann">@Query</span>() query: <span class="tp">ListProductsDto</span>) {
    <span class="kw">return</span> <span class="kw">this</span>.productsService.<span class="fn">findAll</span>(query.cursor, query.limit);
  }

  <span class="ann">@Post</span>()
  <span class="ann">@ApiBearerAuth</span>()
  <span class="ann">@ApiOperation</span>({ summary: <span class="str">'Criar produto'</span> })
  <span class="ann">@ApiBody</span>({ type: <span class="tp">CreateProductDto</span> })
  <span class="ann">@ApiResponse</span>({ status: <span class="num">201</span>, type: <span class="tp">Product</span> })
  <span class="ann">@ApiResponse</span>({ status: <span class="num">422</span>, description: <span class="str">'Dados inválidos'</span> })
  <span class="fn">create</span>(<span class="ann">@Body</span>() dto: <span class="tp">CreateProductDto</span>) {
    <span class="kw">return</span> <span class="kw">this</span>.productsService.<span class="fn">create</span>(dto);
  }
}

<span class="cm">// DTO com decorators que geram schema automáticamente</span>
<span class="kw">export class</span> <span class="tp">CreateProductDto</span> {
  <span class="ann">@ApiProperty</span>({ example: <span class="str">'Camiseta Preta'</span>, maxLength: <span class="num">200</span> })
  <span class="ann">@IsString</span>()
  <span class="ann">@MaxLength</span>(<span class="num">200</span>)
  name: <span class="tp">string</span>;

  <span class="ann">@ApiProperty</span>({ example: <span class="num">99.90</span>, minimum: <span class="num">0</span> })
  <span class="ann">@IsNumber</span>()
  <span class="ann">@Min</span>(<span class="num">0</span>)
  price: <span class="tp">number</span>;

  <span class="ann">@ApiPropertyOptional</span>({ example: <span class="str">'Camiseta 100% algodao'</span> })
  <span class="ann">@IsOptional</span>()
  <span class="ann">@IsString</span>()
  description?: <span class="tp">string</span>;
}</code></pre>

<!-- ═══ 10. MINI SYSTEM DESIGN ═══ -->
<h3>Mini System Design: API Gateway para E-Commerce</h3>
<p><strong>Cenário:</strong> Projete um API Gateway para uma plataforma e-commerce com microsserviços. O gateway deve rotear requests, autenticar usuários, agregar respostas para o app mobile (BFF), e proteger os serviços internos.</p>

<div class="diagram">
<div class="diagram-box orange">Mobile App<br><small>BFF Client</small></div>
<div class="diagram-box cyan">Web App<br><small>SPA</small></div>
<div class="diagram-box purple">3rd Party<br><small>API Keys</small></div>
<div class="diagram-arrow">&rarr;</div>
<div class="diagram-box green">API Gateway<br><small>Kong / AWS APIGW</small></div>
<div class="diagram-arrow">&rarr;</div>
<div class="diagram-box blue">Catalog<br><small>:3001</small></div>
<div class="diagram-box blue">Orders<br><small>:3002</small></div>
<div class="diagram-box blue">Users<br><small>:3003</small></div>
<div class="diagram-box blue">Payments<br><small>:3004</small></div>
</div>

<h4>Decisões de Design</h4>
<ul>
<li><strong>Autenticação:</strong> Gateway válida JWT em todas as requests (exceto /auth/*). Claims do token são passados para os serviços via headers internós (<code>X-User-Id</code>, <code>X-User-Role</code>)</li>
<li><strong>BFF (Backend for Frontend):</strong> O gateway agrega respostas para mobile. Ex: <code>GET /mobile/home</code> chama Catalog + Orders + User em paralelo e retorna um payload único otimizado</li>
<li><strong>Raté Limiting:</strong> 3rd party = 100 req/min por API key. Web/Mobile = 1000 req/min por user. Unauthenticated = 20 req/min por IP</li>
<li><strong>Circuit Breaker:</strong> Se Payments retorna 5xx em >50% dos requests nós últimos 30s, o gateway retorna 503 sem chamar o serviço (fail-fast)</li>
<li><strong>Versionamento:</strong> Gateway roteia <code>/api/v1/*</code> é <code>/api/v2/*</code> para deployments diferentes do mesmo serviço</li>
</ul>

<h4>BFF Aggregation — Implementação</h4>
<pre data-lang="typescript"><code><span class="cm">// mobile-bff.controller.ts — Agregacao para mobile</span>
<span class="ann">@Controller</span>(<span class="str">'mobile'</span>)
<span class="kw">export class</span> <span class="tp">MobileBffController</span> {
  <span class="kw">constructor</span>(
    <span class="kw">private</span> catalogClient: <span class="tp">CatalogClient</span>,
    <span class="kw">private</span> ordersClient: <span class="tp">OrdersClient</span>,
    <span class="kw">private</span> usersClient: <span class="tp">UsersClient</span>,
  ) {}

  <span class="ann">@Get</span>(<span class="str">'home'</span>)
  <span class="kw">async</span> <span class="fn">getHomeFeed</span>(<span class="ann">@Req</span>() req: <span class="tp">AuthRequest</span>) {
    <span class="kw">const</span> userId = req.user.id;

    <span class="cm">// Chamadas paralelas — não sequênciais</span>
    <span class="kw">const</span> [featured, recentOrders, profile] = <span class="kw">await</span> Promise.<span class="fn">allSettled</span>([
      <span class="kw">this</span>.catalogClient.<span class="fn">getFeatured</span>({ limit: <span class="num">10</span> }),
      <span class="kw">this</span>.ordersClient.<span class="fn">getRecent</span>(userId, { limit: <span class="num">3</span> }),
      <span class="kw">this</span>.usersClient.<span class="fn">getProfile</span>(userId),
    ]);

    <span class="cm">// Resiliencia: retorna o que conseguiu, mesmo se um serviço falhou</span>
    <span class="kw">return</span> {
      featured: featured.status === <span class="str">'fulfilled'</span> ? featured.value : [],
      recentOrders: recentOrders.status === <span class="str">'fulfilled'</span> ? recentOrders.value : [],
      profile: profile.status === <span class="str">'fulfilled'</span> ? profile.value : <span class="kw">null</span>,
    };
  }
}</code></pre>

<!-- ═══ 11. ARMADILHAS ═══ -->
<h3>Armadilhas Comuns</h3>

<div class="tip bad">
<span class="tip-icon">&#10060;</span>
<div><strong>Versionar cada endpoint individualmente:</strong> Se <code>/users</code> é v3 mas <code>/orders</code> é v1, a complexidade explode. Versione a API inteira — quando um breaking change é necessário em qualquer endpoint, a API inteira ganha uma nova versão.</div>
</div>

<div class="tip bad">
<span class="tip-icon">&#10060;</span>
<div><strong>API sem política de deprecation:</strong> Nunca remova uma versão sem aviso. Defina um <strong>Sunset period</strong> (mínimo 6-12 meses), comunique via headers, email e changelog. Monitore o tráfego da versão antiga antes de desligar.</div>
</div>

<div class="tip bad">
<span class="tip-icon">&#10060;</span>
<div><strong>API pública sem raté limiting:</strong> Uma API sem raté limit é um convite para DDoS acidental ou proposital. Até APIs internas devem ter limites para evitar cascading failures. Comece com limites generosos e ajuste baseado em observabilidade.</div>
</div>

<div class="tip warn">
<span class="tip-icon">&#9888;</span>
<div><strong>Formatos de erro inconsistentes:</strong> Se <code>/users</code> retorna <code>{ error: "msg" }</code> é <code>/orders</code> retorna <code>{ message: "msg", code: 123 }</code>, o client não consegue tratar erros genéricamente. Padronize com RFC 7807 em toda a API.</div>
</div>

<div class="tip warn">
<span class="tip-icon">&#9888;</span>
<div><strong>Gateway como single point of failure:</strong> O API Gateway deve ser altamente disponível. Use múltiplas instâncias com load balancer, health checks, e failover. Se o gateway cai, tudo cai. Em AWS, API Gateway managed já oferece alta disponibilidade nativa.</div>
</div>

<div class="tip good">
<span class="tip-icon">&#10022;</span>
<div><strong>Regra de ouro:</strong> Traté sua API como um produto. Pense nós consumidores. Documente bem, versione com cuidado, responda com consistência, protejá com raté limits, e comunique mudanças com antecedencia.</div>
</div>

<!-- ═══ EXERCICIOS ═══ -->
<h3>Exercícios Práticos</h3>

<div class="qa">
<div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Exercício 1: Você precisa mudar o campo "userName" para "username" (camelCase para lowercase) na resposta de GET /users. Isso é um breaking change? Como lidar?</div>
<div class="qa-a">
<p><strong>Resposta:</strong> Sim, é um <strong>breaking change</strong> — consumidores que fazem <code>response.userName</code> vao quebrar. A abordagem correta e: (1) Criar v2 que retorna <code>username</code>. (2) Na v1, retornar AMBOS os campos por um período (<code>userName</code> + <code>username</code>) para fácilitar migração. (3) Adicionar header <code>Deprecation: true</code> é <code>Sunset</code> na v1. (4) Monitorar tráfego da v1 e desligar após o sunset period.</p>
</div>
</div>

<div class="qa">
<div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Exercício 2: Seu POST /orders está criando pedidos duplicados quando o cliente faz retry após timeout de rede. Como resolver?</div>
<div class="qa-a">
<p><strong>Resposta:</strong> Implemente <strong>Idempotency Keys</strong>. O cliente gera um UUID (ex: <code>Idempotency-Key: 550e8400-e29b...</code>) e envia no header de cada POST. O servidor armazena a key + resultado em Redis com TTL de 24h. Se receber a mesma key, retorna o resultado armazenado sem reprocessar. Adicione um lock (Redis SETNX) para evitar race conditions de requests simultâneos com a mesma key.</p>
</div>
</div>

<div class="qa">
<div class="qa-q" onclick="this.parentElement.classList.toggle('open')">Exercício 3: Seu API Gateway está se tornando um gargalo. Requests levam 500ms+ só no gateway antes de chegar aos serviços. O que investigar?</div>
<div class="qa-a">
<p><strong>Resposta:</strong> Investigue: (1) <strong>Autenticação síncrona</strong> — se o gateway válida JWT chamando um serviço de auth a cada request, troque para validação local com public key (RS256). (2) <strong>Raté limiting storage</strong> — se o raté limiter usa banco relacional, troque para Redis. (3) <strong>Payload transformation pesada</strong> — se o gateway transforma/agrega payloads, mova essa lógica para um BFF dedicado. (4) <strong>Logging síncrono</strong> — envie logs async para Kafka/SQS. (5) <strong>Conexões</strong> — use connection pooling com keep-alive para os serviços downstream.</p>
</div>
</div>

</div><!-- /section -->

<!-- ═══════════════════ QUIZ ═══════════════════ -->
<div class="quiz-section">
<h3>Quiz — API Design, Versionamento &amp; Gateway</h3>
<p style="color:var(--text2);margin-bottom:24px;font-size:.9rem">Teste seus conhecimentos. 10 perguntas de múltipla escolha. Sua pontuação será salva localmente.</p>

<div id="quiz-container"></div>

<div class="quiz-actions">
<button class="btn btn-primary" id="btn-submit" onclick="submitQuiz()">Verificar Respostas</button>
<button class="btn btn-secondary" id="btn-retry" onclick="resetQuiz()" style="display:none">Refazer Quiz</button>
</div>

<div class="quiz-result" id="quiz-result">
<p style="color:var(--text3);font-size:.8rem;text-transform:uppercase;letter-spacing:1px">Sua Pontuação</p>
<div class="quiz-score" id="quiz-score">0/10</div>
<p style="color:var(--text2);font-size:.88rem" id="quiz-message"></p>
</div>
</div>

<!-- ═══════════════════ WIZARD NAV ═══════════════════ -->
<div class="wizard-nav">
<a href="22-rest-graphql-grpc-websocket.html">&#8592; REST, GraphQL, gRPC &amp; WebSocket</a>
<a href="../fullstack-mastery.html" class="wizard-home" title="Voltar ao Dashboard">&#8962; Home</a>
<a href="24-aws-servicos-essenciais.html" class="primary">Próximo: AWS Serviços Essenciais &#8594;</a>
</div>

</div><!-- /content -->
</div><!-- /main -->

<script>
// ══════════════════════════════════════════
// QUIZ DATA — Seção 23: API Design - Versionamento & Gateway
// ══════════════════════════════════════════
const SECTION_NUM = 23;
const STORAGE_KEY = 'fsm_quiz_' + SECTION_NUM;

const QUIZ_DATA = [
  {
    question: "Qual é a estratégia de versionamento de API mais adotada pela indústria (Google, Stripe, GitHub)?",
    options: [
      "Header versioning (Accept: application/vnd.api.v2+json)",
      "Query parameter (?version=2)",
      "URL Path (/api/v1/users)",
      "Content negotiation via media type"
    ],
    correct: 2,
    explanation: "URL Path (/api/v1/) é a estratégia mais comum na indústria. É a mais explícita, fácil de rotear, cache-friendly é simples de depurar no browser."
  },
  {
    question: "Qual destas mudanças é considerada um NON-breaking change em uma API REST?",
    options: [
      "Renomear um campo existente na resposta",
      "Remover um campo da resposta",
      "Adicionar um campo novo é opcional na resposta",
      "Mudar o tipo de um campo de string para number"
    ],
    correct: 2,
    explanation: "Adicionar campos novos na resposta e non-breaking — consumidores existentes simplesmente ignoram campos que não conhecem. Remover, renomear ou mudar tipo são breaking changes."
  },
  {
    question: "Qual é a principal responsabilidade de um API Gateway?",
    options: [
      "Armazenar dados em banco de dados",
      "Servir como ponto único de entrada, centralizando auth, routing e raté limiting",
      "Compilar código TypeScript para JavaScript",
      "Gerenciar filas de mensagens entre microsserviços"
    ],
    correct: 1,
    explanation: "O API Gateway é o ponto único de entrada para todos os clientes. Centraliza responsabilidades transversais como autenticação, roteamento, raté limiting, CORS e circuit breaking."
  },
  {
    question: "Por que POST precisa de Idempotency Keys, mas GET não?",
    options: [
      "GET é mais lento que POST",
      "POST cria recursos — retries podem duplicar; GET só le dados e já é idempotente",
      "POST não suporta headers customizados",
      "GET sempre retorna dados do cache"
    ],
    correct: 1,
    explanation: "GET e naturalmente idempotente — chamar 2x retorna o mesmo resultado sem efeitos colateráis. POST cria recursos, então um retry após timeout de rede pode criar duplicatas. A Idempotency Key evita isso."
  },
  {
    question: "Na páginação cursor-based, qual é a vantagem principal sobre offset-based?",
    options: [
      "Usa menós memória no servidor",
      "Performance estável em datasets grandes e não pula/duplica itens quando dados mudam",
      "Permite pular diretamente para qualquer página",
      "Retorna contagem total de registros automáticamente"
    ],
    correct: 1,
    explanation: "Cursor-based não precisa contar N rows para pular (como OFFSET faz), então performance não degrada com páginas altas. Além disso, novos inserts não causam duplicatas ou itens pulados."
  },
  {
    question: "O que define o formato RFC 7807 Problem Details?",
    options: [
      "Um padrão para autenticação de APIs",
      "Um formato padrão para respostas de erro com type, title, status, detail e instance",
      "Um protocolo de compressão de payloads JSON",
      "Uma específicação para raté limiting"
    ],
    correct: 1,
    explanation: "RFC 7807 define um formato padrão para erros HTTP: type (URI do tipo de erro), title (resumo), status (HTTP code), detail (explicação) e instance (URL do request). Permite tratamento genérico de erros."
  },
  {
    question: "Qual header deve ser enviado junto com HTTP 429 (Too Many Requests)?",
    options: [
      "X-Forwarded-For",
      "Content-Encoding",
      "Retry-After",
      "Cache-Control"
    ],
    correct: 2,
    explanation: "O header Retry-After indica quantos segundos o cliente deve esperar antes de tentar novamente. É o acompanhamento padrão de uma resposta 429 Too Many Requests."
  },
  {
    question: "No padrão BFF (Backend for Frontend), qual é o papel do API Gateway?",
    options: [
      "Substituir o banco de dados por cache",
      "Agregar respostas de múltiplos microsserviços em um payload otimizado para cada tipo de cliente",
      "Servir arquivos estáticos do frontend",
      "Compilar templates HTML no servidor"
    ],
    correct: 1,
    explanation: "O BFF agrega respostas de múltiplos serviços em um único payload otimizado. Por exemplo, GET /mobile/home chama Catalog + Orders + User em paralelo e retorna tudo junto, reduzindo roundtrips do app mobile."
  },
  {
    question: "Qual abordagem de segurança protege contra alteráção do payload em transito em webhooks?",
    options: [
      "Raté limiting",
      "CORS headers",
      "HMAC request signing (ex: X-Signature-256)",
      "Compressão gzip"
    ],
    correct: 2,
    explanation: "HMAC signing gera um hash do payload com uma secret compartilhada. O receptor recalcula o hash e compara. Se o payload foi alterádo, o hash não bate. Stripe, GitHub e outros usam essa abordagem para webhooks."
  },
  {
    question: "No API-First design, o que acontece ANTES da implementação de código?",
    options: [
      "Deploy em produção para validar infraestrutura",
      "Escrita de testes end-to-end com Cypress",
      "O contrato da API (OpenAPI spec) e projetado e aprovado por frontend e backend",
      "Criação do banco de dados com todas as tabelas"
    ],
    correct: 2,
    explanation: "API-First significa projetar o contrato (OpenAPI spec) antes de escrever código. Frontend e backend concordam no spec, depois trabalham em paralelo: frontend usa mocks gerados do spec, backend implementa contra o contrato."
  }
];

// ══════════════════════════════════════════
// QUIZ ENGINE
// ══════════════════════════════════════════
let submitted = false;

function renderQuiz() {
  const container = document.getElementById('quiz-container');
  let html = '';

  QUIZ_DATA.forEach((q, i) => {
    html += '<div class="quiz-card" id="q' + i + '">';
    html += '<div class="quiz-question"><span class="q-num">' + (i + 1) + '.</span><span>' + q.question + '</span></div>';
    html += '<div class="quiz-options">';
    q.options.forEach((opt, j) => {
      html += '<label class="quiz-option" id="q' + i + 'o' + j + '" onclick="selectOption(' + i + ',' + j + ')">';
      html += '<input type="radio" name="q' + i + '" value="' + j + '"> ' + opt;
      html += '</label>';
    });
    html += '</div>';
    html += '<div class="quiz-explanation" id="q' + i + 'exp">' + q.explanation + '</div>';
    html += '</div>';
  });

  container.innerHTML = html;
}

function selectOption(qIdx, oIdx) {
  if (submitted) return;
  const options = document.querySelectorAll('#q' + qIdx + ' .quiz-option');
  options.forEach(o => o.classList.remove('selected'));
  document.getElementById('q' + qIdx + 'o' + oIdx).classList.add('selected');
}

function submitQuiz() {
  if (submitted) return;
  submitted = true;

  let score = 0;

  QUIZ_DATA.forEach((q, i) => {
    const selected = document.querySelector('input[name="q' + i + '"]:checked');
    const selectedIdx = selected ? parseInt(selected.value) : -1;

    // Show explanation
    document.getElementById('q' + i + 'exp').classList.add('visible');

    // Mark correct/wrong
    if (selectedIdx === q.correct) {
      score++;
      document.getElementById('q' + i + 'o' + selectedIdx).classList.add('correct');
    } else {
      if (selectedIdx >= 0) {
        document.getElementById('q' + i + 'o' + selectedIdx).classList.add('wrong');
      }
      document.getElementById('q' + i + 'o' + q.correct).classList.add('correct');
    }
  });

  // Show result
  const result = document.getElementById('quiz-result');
  const scoreEl = document.getElementById('quiz-score');
  const msgEl = document.getElementById('quiz-message');
  result.classList.add('visible');
  scoreEl.textContent = score + '/10';

  if (score >= 8) {
    scoreEl.className = 'quiz-score';
    msgEl.textContent = 'Excelente! Você domina API Design, Versionamento e Gateway.';
  } else if (score >= 5) {
    scoreEl.className = 'quiz-score mid';
    msgEl.textContent = 'Bom, mas revise os conceitos que errou.';
  } else {
    scoreEl.className = 'quiz-score low';
    msgEl.textContent = 'Recomendado: releia a seção e tente novamente.';
  }

  // Save to localStorage
  const data = { score: score, total: 10, completedAt: new Date().toISOString() };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  // Toggle buttons
  document.getElementById('btn-submit').style.display = 'none';
  document.getElementById('btn-retry').style.display = 'inline-flex';
}

function resetQuiz() {
  submitted = false;
  document.getElementById('quiz-result').classList.remove('visible');
  document.getElementById('btn-submit').style.display = 'inline-flex';
  document.getElementById('btn-retry').style.display = 'none';
  renderQuiz();
}

// Check for previous score
function loadPreviousScore() {
  const saved = localStorage.getItem(STORAGE_KEY);
  if (saved) {
    try {
      const data = JSON.parse(saved);
      const tip = document.createElement('div');
      tip.className = 'tip info';
      tip.innerHTML = '<span class="tip-icon">i</span><div>Você já fez este quiz antes e tirou <strong>' + data.score + '/10</strong>. Pode refazer para melhorar sua nota.</div>';
      document.querySelector('.quiz-section').insertBefore(tip, document.getElementById('quiz-container'));
    } catch(e) {}
  }
}

// Init
renderQuiz();
loadPreviousScore();
</script>
</body>
</html>
